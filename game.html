<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cat & Yarn Runner — Gra (2 skoki w powietrzu)</title>
  <link rel="icon" href="favicon.png">
  <link rel="stylesheet" href="style.css">
  <style>
    body { background: #1b1f2a; color:#fff; }
    .wrap { display:flex; flex-direction:column; align-items:center; gap:14px; padding: 16px; }
    canvas { background: linear-gradient(#87cefa, #bde4ff 60%, #c7f5ff); border-radius: 12px; box-shadow: 0 12px 36px rgba(0,0,0,.35); max-width: 100%; height: auto; }
    .hud { display:flex; gap:20px; font-weight:800; }
    .btnbar { display:none; gap:10px; }
    .btn { padding:12px 16px; border-radius:10px; background:#2b3144; border:1px solid #445072; color:#fff; }
    @media (max-width: 820px) { .btnbar { display:flex; flex-wrap:wrap; } }
    a.back { text-decoration:none; color:#fff; opacity:.9; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="score">Kłębki: 0</div>
      <div id="lives">Życia: 3</div>
      <div id="hint" class="legend">Sterowanie: ← → / A D — ruch, Spacja — skok (2× w powietrzu), R — restart</div>
    </div>
    <canvas id="game" width="960" height="540" aria-label="Gra o kocie, zbieranie kłębków włóczki"></canvas>
    <div class="btnbar">
      <div class="btn" data-btn="left">←</div>
      <div class="btn" data-btn="right">→</div>
      <div class="btn" data-btn="jump">Skok</div>
      <div class="btn" data-btn="reset">R</div>
    </div>
    <div><a class="back" href="index.html">⟵ Wróć</a></div>
  </div>

<script>
(() => {
  let audioCtx, musicGain, sfxGain, started=false;
  const startAudio=()=>{ if(started) return; started=true;
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    musicGain=audioCtx.createGain(); musicGain.gain.value=0.22; musicGain.connect(audioCtx.destination);
    sfxGain=audioCtx.createGain(); sfxGain.gain.value=0.5; sfxGain.connect(audioCtx.destination);
    startMusic();
  };
  const blip=(hz,dur=0.12,type="square",vol=0.35)=>{
    if(!audioCtx) return; const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type=type; o.frequency.value=hz; g.gain.value=0; o.connect(g); g.connect(sfxGain);
    const t=audioCtx.currentTime; g.gain.linearRampToValueAtTime(vol,t+0.01); g.gain.exponentialRampToValueAtTime(0.001,t+dur);
    o.start(t); o.stop(t+dur+0.02);
  };
  const miau=()=>{ blip(660,0.08,"triangle",0.35); setTimeout(()=>blip(880,0.10,"triangle",0.3),60); };
  const jumpSfx=()=>{ blip(520,0.09,"square",0.3); setTimeout(()=>blip(740,0.07,"square",0.25),60); };
  function startMusic(){
    const bpm=126, beat=60/bpm, t0=audioCtx.currentTime+0.05; const master=audioCtx.createGain(); master.gain.value=0.25; master.connect(musicGain);
    function voice(t,f,len,vol,type="square"){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type=type; o.frequency.value=f; g.gain.value=0; o.connect(g); g.connect(master);
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vol,t+0.01); g.gain.exponentialRampToValueAtTime(0.0008,t+len); o.start(t); o.stop(t+len+0.05); }
    for(let bar=0; bar<32; bar++){ const tBar=t0+bar*8*beat;
      [0,1,2,3,4,5,6,7].forEach(i=>voice(tBar+i*beat,[659,784,880,988,880,784,659,587][i],0.3,0.16,"square"));
      [0,1,2,3,4,5,6,7].forEach(i=>voice(tBar+i*beat,[110,110,147,147,165,165,147,147][i],0.45,0.18,"sawtooth"));
    }
  }
  window.addEventListener('pointerdown', startAudio); window.addEventListener('keydown', startAudio);

  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const TILE=48, GRAV=0.7, JUMP_VY=-13.0, MOVE_AX=1.0, MOVE_MAX=5.0, FRICTION=0.80;
  const HUD={score:document.getElementById('score'), lives:document.getElementById('lives')};

  const level=[
    "                                                                 ",
    "                                                                 ",
    "                                                                 ",
    "                 o             ---                               ",
    "            ---             o        o                           ",
    "       o                     ###                                  ",
    "                                o         e                       ",
    "           o        ---               #######                     ",
    "   S                   o                                    F     ",
    "##########      ####         e       #########      ##############",
    "##########  o   ####   o             #########   o  ##############",
    "##########      ####         o        #########      ##############"
  ];

  const W=level[0].length*TILE, H=level.length*TILE; canvas.width=960; canvas.height=540;
  function tileAt(px,py){ const tx=Math.floor(px/TILE), ty=Math.floor(py/TILE); if(ty<0||ty>=level.length||tx<0||tx>=level[0].length) return '#'; return level[ty][tx];}
  function isSolid(ch){ return ch==='#'||ch==='-'; }
  function rectVsSolid(rx,ry,rw,rh){
    const left=Math.floor(rx/TILE), right=Math.floor((rx+rw)/TILE), top=Math.floor(ry/TILE), bottom=Math.floor((ry+rh)/TILE);
    const contacts=[];
    for(let ty=top;ty<=bottom;ty++) for(let tx=left;tx<=right;tx++){
      const ch=(ty<0||ty>=level.length||tx<0||tx>=level[0].length)?'#':level[ty][tx];
      if(isSolid(ch)){
        const tileX=tx*TILE, tileY=ty*TILE, ox=(rx+rw/2)-(tileX+TILE/2), oy=(ry+rh/2)-(tileY+TILE/2);
        const hx=rw/2+TILE/2, hy=rh/2+TILE/2, px=hx-Math.abs(ox), py=hy-Math.abs(oy);
        if(px>0 && py>0){ if(px<py){ const nx=(ox>0)?1:-1; contacts.push({nx,ny:0,pen:px}); } else { const ny=(oy>0)?1:-1; contacts.push({nx:0,ny,pen:py}); } }
      }
    }
    return contacts;
  }

  const yarns=[], enemies=[]; let startX=0,startY=0, finishRect={x:0,y:0,w:TILE,h:2*TILE};
  for(let y=0;y<level.length;y++) for(let x=0;x<level[0].length;x++){
    const ch=level[y][x];
    if(ch==='o') yarns.push({x:x*TILE+TILE/2,y:y*TILE+TILE/2,r:12,taken:false,bob:Math.random()*6.28});
    if(ch==='e') enemies.push({x:x*TILE+8,y:y*TILE,w:32,h:40,vx:1.2,dir:1,alive:true});
    if(ch==='S'){ startX=x*TILE; startY=y*TILE; }
    if(ch==='F'){ finishRect={x:x*TILE,y:y*TILE-TILE,w:TILE,h:2*TILE}; }
  }

  const cat={ x:startX,y:startY-2,w:34,h:42,vx:0,vy:0,onGround:false,facing:1, airJumpsUsed:0, maxAirJumps:2 };
  const camera={x:0,y:0}; let score=0,lives=3,gameOver=false,win=false;

  const keys=new Set();
  document.addEventListener('keydown',e=>{ if(['ArrowLeft','ArrowRight','ArrowUp',' '].includes(e.key)) e.preventDefault(); keys.add(e.key.toLowerCase()); if(e.key.toLowerCase()==='r') reset(); });
  document.addEventListener('keyup',e=>keys.delete(e.key.toLowerCase()));

  const stateTouch={left:false,right:false,jump:false};
  const bindBtn=(name,prop)=>{ const el=document.querySelector(`.btn[data-btn="${name}"]`); if(!el) return;
    const on=v=>stateTouch[prop]=v;
    ['pointerdown','touchstart','mousedown'].forEach(ev=>el.addEventListener(ev,()=>on(true)));
    ['pointerup','touchend','mouseup','mouseleave','touchcancel'].forEach(ev=>el.addEventListener(ev,()=>on(false)));
  };
  bindBtn('left','left'); bindBtn('right','right'); bindBtn('jump','jump');
  const resetBtn=document.querySelector('.btn[data-btn="reset"]'); if(resetBtn) resetBtn.addEventListener('click',()=>reset());

  const inputLeft = ()=> keys.has('arrowleft')||keys.has('a')||stateTouch.left;
  const inputRight= ()=> keys.has('arrowright')||keys.has('d')||stateTouch.right;
  const inputJumpHeld = ()=> keys.has(' ')||keys.has('arrowup')||keys.has('w')||stateTouch.jump;

  // Rising-edge detection so each press counts once
  let prevJump=false;
  const jumpJustPressed = ()=>{ const cur=inputJumpHeld(); const jp=cur && !prevJump; prevJump=cur; return jp; };

  function doJump(){ cat.vy=JUMP_VY; cat.onGround=false; jumpSfx(); }

  function reset(){
    Object.assign(cat,{x:startX,y:startY-2,vx:0,vy:0,onGround:false,facing:1, airJumpsUsed:0});
    score=0;lives=3;gameOver=false;win=false;
    yarns.forEach(y=>y.taken=false); enemies.forEach(e=>{e.alive=true; e.dir=1;});
    HUD.score.textContent=`Kłębki: ${score}`; HUD.lives.textContent=`Życia: ${lives}`;
  }

  function killCat(){ lives--; HUD.lives.textContent=`Życia: ${lives}`; if(lives<=0){gameOver=true;} else {Object.assign(cat,{x:startX,y:startY-2,vx:0,vy:0,onGround:false, airJumpsUsed:0});} }

  function stompEnemy(e, fromAbove){ if(!e.alive) return; if(fromAbove){ e.alive=false; cat.vy=JUMP_VY*0.6; score+=5; HUD.score.textContent=`Kłębki: ${score}`; } else { killCat(); } }

  function update(dt){
    if(gameOver||win) return;

    if(jumpJustPressed()){
      if(cat.onGround){ doJump(); cat.airJumpsUsed=0; }
      else if(cat.airJumpsUsed < cat.maxAirJumps){ doJump(); cat.airJumpsUsed++; }
    }

    if(inputLeft()){ cat.vx-=MOVE_AX; cat.facing=-1; }
    if(inputRight()){ cat.vx+=MOVE_AX; cat.facing=1; }
    cat.vx=Math.max(-MOVE_MAX, Math.min(MOVE_MAX, cat.vx));

    cat.vy+=GRAV;

    cat.x+=cat.vx;
    let contacts=rectVsSolid(cat.x,cat.y,cat.w,cat.h);
    for(const c of contacts){ if(c.nx!==0){ cat.x+=c.nx*c.pen; cat.vx=0; } }

    cat.y+=cat.vy;
    contacts=rectVsSolid(cat.x,cat.y,cat.w,cat.h); cat.onGround=false;
    for(const c of contacts){
      if(c.ny!==0){
        cat.y+=c.ny*c.pen;
        if(c.ny<0){ cat.onGround=true; cat.vy=0; cat.airJumpsUsed=0; } else { cat.vy=0; }
      }
    }

    if(cat.onGround && !(inputLeft()||inputRight())){ cat.vx*=0.80; if(Math.abs(cat.vx)<0.05) cat.vx=0; }

    for(const y of yarns){
      if(y.taken) continue;
      const dx=(cat.x+cat.w/2)-y.x, dy=(cat.y+cat.h/2)-y.y;
      if(Math.hypot(dx,dy) < (y.r + Math.min(cat.w,cat.h)/2 * 0.8)){ y.taken=true; score+=1; HUD.score.textContent=`Kłębki: ${score}`; miau(); }
      y.bob += 0.05;
    }

    for(const e of enemies){
      if(!e.alive) continue;
      e.x += e.vx * e.dir;
      const aheadX = e.dir > 0 ? e.x + e.w : e.x - 1;
      const footY = e.y + e.h + 1;
      const wall = isSolid(tileAt(aheadX, e.y + e.h/2));
      const ground = isSolid(tileAt(aheadX, footY));
      if(wall || !ground) e.dir *= -1;
      const overlap = !(cat.x+cat.w < e.x || cat.x > e.x+e.w || cat.y+cat.h < e.y || cat.y > e.y+e.h);
      if(overlap){
        const fromAbove = (cat.vy > 0 && (cat.y + cat.h) - e.y < 18);
        stompEnemy(e, fromAbove);
      }
    }

    const pX=cat.x+cat.w/2, pY=cat.y+cat.h/2;
    if(pX>finishRect.x && pX<finishRect.x+finishRect.w && pY>finishRect.y && pY<finishRect.y+finishRect.h){ win=true; }
    if(cat.y > H + 200) killCat();

    const viewW=canvas.width, viewH=canvas.height;
    camera.x = Math.max(0, Math.min(W - viewW, cat.x + cat.w/2 - viewW/2));
    camera.y = Math.max(0, Math.min(H - viewH, cat.y + cat.h/2 - viewH/2));
  }

  function drawTile(tx,ty,ch){
    const x=tx*TILE - camera.x, y=ty*TILE - camera.y;
    if(ch==='#'){ ctx.fillStyle='#6c4e2a'; ctx.fillRect(x,y,TILE,TILE); ctx.fillStyle='#8f6a3b'; ctx.fillRect(x,y,TILE,10); }
    else if(ch==='-'){ ctx.fillStyle='#445072'; ctx.fillRect(x,y+TILE/2,TILE,10); ctx.fillStyle='#2b3144'; ctx.fillRect(x,y+TILE/2+10,TILE,6); }
  }

  function drawCat(){
    const x=Math.floor(cat.x - camera.x), y=Math.floor(cat.y - camera.y);
    ctx.fillStyle='#ffffff'; ctx.fillRect(x,y,cat.w,cat.h);
    ctx.fillStyle='#ffffff'; ctx.fillRect(x, y-14, cat.w, 16);
    ctx.fillStyle='#92c5ff'; const eyeX = cat.facing>0 ? x+cat.w-14 : x+8; ctx.fillRect(eyeX, y-8, 6, 6);
    ctx.strokeStyle='#ffffff'; ctx.lineWidth=6; ctx.beginPath(); ctx.moveTo(x-4,y+10); ctx.quadraticCurveTo(x-18,y,x-10,y-12); ctx.stroke();
  }

  function drawYarn(o){
    const sx=Math.floor(o.x - camera.x), sy=Math.floor(o.y - camera.y + Math.sin(o.bob)*3);
    if(o.taken) return;
    ctx.fillStyle='#ff89c0'; ctx.beginPath(); ctx.arc(sx,sy,o.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#ffb3d5'; ctx.lineWidth=2; ctx.beginPath();
    for(let a=0;a<Math.PI*2;a+=Math.PI/3){ ctx.moveTo(sx+Math.cos(a)*o.r, sy+Math.sin(a)*o.r); ctx.lineTo(sx+Math.cos(a+0.8)*o.r*0.6, sy+Math.sin(a+0.8)*o.r*0.6); }
    ctx.stroke();
  }

  function drawEnemy(e){
    if(!e.alive) return;
    const x=Math.floor(e.x - camera.x), y=Math.floor(e.y - camera.y);
    ctx.fillStyle='#7b7b86'; ctx.fillRect(x,y+8,e.w,e.h-8);
    ctx.fillStyle='#8f8f99'; ctx.beginPath(); ctx.arc(x+e.w/2,y+10,14,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#222'; ctx.fillRect(x+e.w/2+4,y+6,3,3);
  }

  function drawFinish(){
    const x=Math.floor(finishRect.x - camera.x), y=Math.floor(finishRect.y - camera.y);
    ctx.fillStyle='#e5eefc'; ctx.fillRect(x+TILE/2-2, y, 4, finishRect.h);
    ctx.fillStyle='#ff4d6d'; ctx.beginPath(); ctx.moveTo(x+TILE/2+2,y+10); ctx.lineTo(x+TILE/2+2+30,y+18); ctx.lineTo(x+TILE/2+2,y+26); ctx.closePath(); ctx.fill();
  }

  function banner(text){ ctx.save(); ctx.globalAlpha=0.75; ctx.fillStyle='#000'; ctx.fillRect(80, canvas.height/2 - 60, canvas.width-160, 120); ctx.restore();
    ctx.textAlign='center'; ctx.font='28px system-ui, sans-serif'; ctx.fillStyle='#fff'; ctx.fillText(text, canvas.width/2, canvas.height/2 + 8); }

  let last=performance.now();
  function frame(now){
    const dt=Math.min(33, now-last)/16.67; last=now;
    update(dt);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const cx = -(camera.x*0.3)%300, cy=40; ctx.fillStyle='rgba(255,255,255,0.8)';
    for(let i=-1;i<5;i++){ const bx=cx+i*300; ctx.beginPath(); ctx.ellipse(bx+60, cy+10, 50, 28, 0, 0, Math.PI*2); ctx.ellipse(bx+100, cy+5, 40, 24, 0, 0, Math.PI*2); ctx.ellipse(bx+20, cy+5, 35, 22, 0, 0, Math.PI*2); ctx.fill(); }
    for(let ty=0; ty<level.length; ty++) for(let tx=0; tx<level[0].length; tx++){ const ch=level[ty][tx]; if(ch===' '||ch==='S'||ch==='o'||ch==='e') continue; drawTile(tx,ty,ch); }
    yarns.forEach(drawYarn); enemies.forEach(drawEnemy); drawFinish(); drawCat();
    if(gameOver) banner("Koci odpoczynek… Naciśnij R"); if(win) banner(`Wygrana! Kłębków: ${score}. R aby zagrać ponownie`);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  if (window.matchMedia("(max-width: 820px)").matches) { document.querySelector('.btnbar').style.display = 'flex'; }
})();
</script>
</body>
</html>
