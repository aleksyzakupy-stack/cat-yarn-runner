<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cat & Yarn Runner — Gra</title>
  <link rel="icon" href="favicon.png">
  <link rel="stylesheet" href="style.css">
  <style>
    body { background: #1b1f2a; color:#fff; }
    .wrap { display:flex; flex-direction:column; align-items:center; gap:14px; padding: 16px; }
    canvas { background: linear-gradient(#87cefa, #bde4ff 60%, #c7f5ff); border-radius: 12px; box-shadow: 0 12px 36px rgba(0,0,0,.35); max-width: 100%; height: auto; }
    .hud { display:flex; gap:20px; font-weight:800; }
    .btnbar { display:none; gap:10px; }
    .btn { padding:12px 16px; border-radius:10px; background:#2b3144; border:1px solid #445072; }
    @media (max-width: 820px) { .btnbar { display:flex; flex-wrap:wrap; } }
    a.back { text-decoration:none; color:#fff; opacity:.9; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="score">Kłębki: 0</div>
      <div id="lives">Życia: 3</div>
      <div id="hint" class="legend">Sterowanie: ← → / A D — ruch, Spacja — skok, R — restart</div>
    </div>
    <canvas id="game" width="960" height="540" aria-label="Gra o kocie, zbieranie kłębków włóczki"></canvas>
    <div class="btnbar">
      <div class="btn" data-btn="left">←</div>
      <div class="btn" data-btn="right">→</div>
      <div class="btn" data-btn="jump">Skok</div>
      <div class="btn" data-btn="reset">R</div>
    </div>
    <div><a class="back" href="index.html">⟵ Wróć</a></div>
  </div>

<script>
(() => {
  // ---------- Simple WebAudio SFX & music ----------
  let audioCtx, musicGain, sfxGain, started = false;
  const startAudio = () => {
    if (started) return;
    started = true;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    musicGain = audioCtx.createGain(); musicGain.gain.value = 0.25; musicGain.connect(audioCtx.destination);
    sfxGain = audioCtx.createGain(); sfxGain.gain.value = 0.5; sfxGain.connect(audioCtx.destination);
    startMusic();
  };
  const note = (hz, dur=0.15, type="sine", vol=0.6) => {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = hz;
    g.gain.value = 0;
    o.connect(g); g.connect(sfxGain);
    const t = audioCtx.currentTime;
    g.gain.linearRampToValueAtTime(vol, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    o.start(t); o.stop(t + dur + 0.02);
  };
  const miau = () => { // soft "miau"
    note(660, 0.08, "triangle", 0.4);
    setTimeout(()=>note(880, 0.12, "triangle", 0.3), 50);
  };
  const jumpSfx = () => {
    note(520, 0.1, "square", 0.3);
    setTimeout(()=>note(740, 0.08, "square", 0.25), 70);
  };

  // very light chiptune loop
  function startMusic(){
    const bpm = 126, beat = 60/bpm;
    const t0 = audioCtx.currentTime + 0.05;
    const master = audioCtx.createGain(); master.gain.value = 0.25;
    master.connect(musicGain);

    function lead(t, n, len, vol){
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "square";
      o.frequency.value = n;
      g.gain.value = 0;
      o.connect(g); g.connect(master);
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(vol, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0008, t+len);
      o.start(t); o.stop(t+len+0.05);
    }
    function bass(t, n, len, vol){
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sawtooth";
      o.frequency.value = n;
      g.gain.value = 0;
      o.connect(g); g.connect(master);
      g.gain.linearRampToValueAtTime(vol, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.001, t+len);
      o.start(t); o.stop(t+len+0.05);
    }
    // loop pattern 2 bars
    for (let bar=0; bar<32; bar++){ // schedule long loop
      const tBar = t0 + bar*8*beat;
      // bass
      bass(tBar+0*beat, 110, 0.45, 0.18);
      bass(tBar+1*beat, 110, 0.45, 0.18);
      bass(tBar+2*beat, 147, 0.45, 0.18);
      bass(tBar+3*beat, 147, 0.45, 0.18);
      bass(tBar+4*beat, 165, 0.45, 0.18);
      bass(tBar+5*beat, 165, 0.45, 0.18);
      bass(tBar+6*beat, 147, 0.45, 0.18);
      bass(tBar+7*beat, 147, 0.45, 0.18);

      // lead
      lead(tBar+0*beat, 659, 0.32, 0.16);
      lead(tBar+1*beat, 784, 0.32, 0.16);
      lead(tBar+2*beat, 880, 0.32, 0.16);
      lead(tBar+3*beat, 988, 0.32, 0.16);
      lead(tBar+4*beat, 880, 0.32, 0.16);
      lead(tBar+5*beat, 784, 0.32, 0.16);
      lead(tBar+6*beat, 659, 0.32, 0.16);
      lead(tBar+7*beat, 587, 0.32, 0.16);
    }
  }

  // Resume audio on first interaction
  window.addEventListener('pointerdown', startAudio, {once:false});
  window.addEventListener('keydown', startAudio, {once:false});

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const TILE = 48;
  const GRAV = 0.7;
  const JUMP_VY = -13.0;
  const MOVE_AX = 1.0;
  const MOVE_MAX = 5.0;
  const FRICTION = 0.80;

  const HUD = {
    score: document.getElementById('score'),
    lives: document.getElementById('lives')
  };

  // Poziom
  const level = [
    "                                                                 ",
    "                                                                 ",
    "                                                                 ",
    "                 o             ---                               ",
    "            ---             o        o                           ",
    "       o                     ###                                  ",
    "                                o         e                       ",
    "           o        ---               #######                     ",
    "   S                   o                                    F     ",
    "##########      ####         e       #########      ##############",
    "##########  o   ####   o             #########   o  ##############",
    "##########      ####         o        #########      ##############"
  ];

  const W = level[0].length * TILE;
  const H = level.length * TILE;
  canvas.width = 960;
  canvas.height = 540;

  function tileAt(px, py) {
    const tx = Math.floor(px / TILE);
    const ty = Math.floor(py / TILE);
    if (ty < 0 || ty >= level.length || tx < 0 || tx >= level[0].length) return '#';
    return level[ty][tx];
  }
  function isSolid(ch) { return ch === '#' || ch === '-'; }
  function rectVsSolid(rx, ry, rw, rh) {
    const left = Math.floor((rx) / TILE);
    const right = Math.floor((rx + rw) / TILE);
    const top = Math.floor((ry) / TILE);
    const bottom = Math.floor((ry + rh) / TILE);
    const contacts = [];
    for (let ty = top; ty <= bottom; ty++) {
      for (let tx = left; tx <= right; tx++) {
        const ch = (ty < 0 || ty >= level.length || tx < 0 || tx >= level[0].length) ? '#' : level[ty][tx];
        if (isSolid(ch)) {
          const tileX = tx * TILE;
          const tileY = ty * TILE;
          const overlapX = (rx + rw/2) - (tileX + TILE/2);
          const overlapY = (ry + rh/2) - (tileY + TILE/2);
          const halfW = (rw/2 + TILE/2);
          const halfH = (rh/2 + TILE/2);
          const penX = halfW - Math.abs(overlapX);
          const penY = halfH - Math.abs(overlapY);
          if (penX > 0 && penY > 0) {
            if (penX < penY) {
              const nx = (overlapX > 0) ? 1 : -1;
              contacts.push({ nx, ny:0, pen: penX, tx, ty });
            } else {
              const ny = (overlapY > 0) ? 1 : -1;
              contacts.push({ nx:0, ny, pen: penY, tx, ty });
            }
          }
        }
      }
    }
    return contacts;
  }

  // Obiekty
  const yarns = [];
  const enemies = [];
  let startX = 0, startY = 0, finishRect = {x:0,y:0,w:TILE,h:2*TILE};
  for (let y = 0; y < level.length; y++) {
    for (let x = 0; x < level[0].length; x++) {
      const ch = level[y][x];
      if (ch === 'o') yarns.push({x:x*TILE+TILE/2, y:y*TILE+TILE/2, r:12, taken:false, bob: Math.random()*Math.PI*2});
      if (ch === 'e') enemies.push({x:x*TILE+8, y:y*TILE, w:32, h:40, vx: 1.2, dir: 1, alive:true});
      if (ch === 'S') { startX = x*TILE; startY = y*TILE; }
      if (ch === 'F') { finishRect = {x:x*TILE, y:y*TILE- TILE, w:TILE, h:2*TILE}; }
    }
  }

  const cat = { x:startX, y:startY-2, w:34, h:42, vx:0, vy:0, onGround:false, facing:1 };
  const camera = { x:0, y:0 };
  let score = 0, lives = 3, gameOver = false, win = false;

  const keys = new Set();
  document.addEventListener('keydown', (e) => {
    if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' '].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if (e.key.toLowerCase() === 'r') reset();
  });
  document.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  const btnbar = document.querySelector('.btnbar');
  const stateTouch = { left:false, right:false, jump:false };
  function bindBtn(name, prop) {
    const el = document.querySelector(`.btn[data-btn="${name}"]`);
    if (!el) return;
    const on = (v)=>{ stateTouch[prop]=v; };
    ['pointerdown','touchstart','mousedown'].forEach(ev=> el.addEventListener(ev, ()=>on(true)));
    ['pointerup','touchend','mouseup','mouseleave','touchcancel'].forEach(ev=> el.addEventListener(ev, ()=>on(false)));
  }
  bindBtn('left','left'); bindBtn('right','right'); bindBtn('jump','jump');
  const resetBtn = document.querySelector('.btn[data-btn="reset"]'); if (resetBtn) resetBtn.addEventListener('click', ()=>reset());

  function inputLeft() { return keys.has('arrowleft') || keys.has('a') || stateTouch.left; }
  function inputRight() { return keys.has('arrowright') || keys.has('d') || stateTouch.right; }
  function inputJump() { return keys.has(' ') || keys.has('arrowup') || keys.has('w') || stateTouch.jump; }

  function reset() {
    cat.x = startX; cat.y = startY - 2;
    cat.vx = 0; cat.vy = 0; cat.onGround = false; cat.facing = 1;
    score = 0; lives = 3; gameOver = false; win = false;
    yarns.forEach(y=> y.taken=false);
    enemies.forEach(e=> {e.alive=true; e.x = Math.round(e.x/TILE)*TILE + 8; e.vx = Math.sign(e.vx)||1; e.dir = Math.sign(e.vx)||1;});
    HUD.score.textContent = `Kłębki: ${score}`;
    HUD.lives.textContent = `Życia: ${lives}`;
  }

  function killCat() {
    lives--;
    if (lives <= 0) { gameOver = true; } else {
      cat.x = startX; cat.y = startY - 2; cat.vx = 0; cat.vy = 0; cat.onGround = false;
    }
    HUD.lives.textContent = `Życia: ${lives}`;
  }

  function stompEnemy(e, fromAbove) {
    if (!e.alive) return;
    if (fromAbove) {
      e.alive = false;
      cat.vy = JUMP_VY * 0.6;
      score += 5;
      HUD.score.textContent = `Kłębki: ${score}`;
    } else {
      killCat();
    }
  }

  function update(dt) {
    if (gameOver || win) return;
    if (!started && (inputLeft()||inputRight()||inputJump())) startAudio();

    if (inputLeft()) { cat.vx -= 1.0; cat.facing = -1; }
    if (inputRight()) { cat.vx += 1.0; cat.facing = 1; }
    cat.vx = Math.max(-MOVE_MAX, Math.min(MOVE_MAX, cat.vx));

    cat.vy += GRAV;

    if (inputJump() && cat.onGround) {
      cat.vy = JUMP_VY;
      cat.onGround = false;
      jumpSfx();
    }

    cat.x += cat.vx;
    let contacts = rectVsSolid(cat.x, cat.y, cat.w, cat.h);
    for (const c of contacts) if (c.nx !== 0) { cat.x += c.nx * c.pen; cat.vx = 0; }

    cat.y += cat.vy;
    contacts = rectVsSolid(cat.x, cat.y, cat.w, cat.h); cat.onGround = false;
    for (const c of contacts) {
      if (c.ny !== 0) {
        cat.y += c.ny * c.pen;
        if (c.ny < 0) { cat.onGround = true; cat.vy = 0; } else if (c.ny > 0) { cat.vy = 0; }
      }
    }

    if (cat.onGround && !(inputLeft() || inputRight())) { cat.vx *= FRICTION; if (Math.abs(cat.vx) < 0.05) cat.vx = 0; }

    for (const y of yarns) {
      if (y.taken) continue;
      const dx = (cat.x + cat.w/2) - y.x;
      const dy = (cat.y + cat.h/2) - y.y;
      if (Math.hypot(dx,dy) < (y.r + Math.min(cat.w,cat.h)/2 * 0.8)) {
        y.taken = true; score += 1; HUD.score.textContent = `Kłębki: ${score}`; miau();
      }
      y.bob += 0.05;
    }

    for (const e of enemies) {
      if (!e.alive) continue;
      e.x += e.vx * e.dir;
      const aheadX = e.dir > 0 ? e.x + e.w : e.x - 1;
      const footY = e.y + e.h + 1;
      const wall = isSolid(tileAt(aheadX, e.y + e.h/2));
      const ground = isSolid(tileAt(aheadX, footY));
      if (wall || !ground) e.dir *= -1;
      const overlap = !(cat.x+cat.w < e.x || cat.x > e.x+e.w || cat.y+cat.h < e.y || cat.y > e.y+e.h);
      if (overlap) {
        const fromAbove = (cat.vy > 0 && (cat.y + cat.h) - e.y < 18);
        stompEnemy(e, fromAbove);
      }
    }

    const pX = cat.x + cat.w/2, pY = cat.y + cat.h/2;
    if (pX > finishRect.x && pX < finishRect.x + finishRect.w && pY > finishRect.y && pY < finishRect.y + finishRect.h) { win = true; }

    if (cat.y > H + 200) killCat();

    const viewW = canvas.width, viewH = canvas.height;
    camera.x = Math.max(0, Math.min(W - viewW, cat.x + cat.w/2 - viewW/2));
    camera.y = Math.max(0, Math.min(H - viewH, cat.y + cat.h/2 - viewH/2));
  }

  function drawTile(tx, ty, ch) {
    const x = tx*TILE - camera.x;
    const y = ty*TILE - camera.y;
    if (ch === '#') {
      ctx.fillStyle = '#6c4e2a'; ctx.fillRect(x, y, TILE, TILE);
      ctx.fillStyle = '#8f6a3b'; ctx.fillRect(x, y, TILE, 10);
    } else if (ch === '-') {
      ctx.fillStyle = '#445072'; ctx.fillRect(x, y+TILE/2, TILE, 10);
      ctx.fillStyle = '#2b3144'; ctx.fillRect(x, y+TILE/2+10, TILE, 6);
    }
  }

  function drawCat() {
    const x = Math.floor(cat.x - camera.x);
    const y = Math.floor(cat.y - camera.y);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(x, y, cat.w, cat.h);
    ctx.fillStyle = '#ffffff'; // head + ears
    ctx.fillRect(x, y-14, cat.w, 16);
    ctx.fillStyle = '#92c5ff'; // eye
    const eyeX = cat.facing>0 ? x+cat.w-14 : x+8;
    ctx.fillRect(eyeX, y-8, 6, 6);
    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 6;
    ctx.beginPath(); ctx.moveTo(x-4, y+10); ctx.quadraticCurveTo(x-18, y, x-10, y-12); ctx.stroke();
  }

  function drawYarn(y) {
    const sx = Math.floor(y.x - camera.x);
    const sy = Math.floor(y.y - camera.y + Math.sin(y.bob)*3);
    if (y.taken) return;
    ctx.fillStyle = '#ff89c0';
    ctx.beginPath(); ctx.arc(sx, sy, y.r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#ffb3d5'; ctx.lineWidth = 2; ctx.beginPath();
    for (let a=0;a<Math.PI*2;a+=Math.PI/3) { ctx.moveTo(sx+Math.cos(a)*y.r, sy+Math.sin(a)*y.r); ctx.lineTo(sx+Math.cos(a+0.8)*y.r*0.6, sy+Math.sin(a+0.8)*y.r*0.6); }
    ctx.stroke();
  }

  function drawEnemy(e) {
    if (!e.alive) return;
    const x = Math.floor(e.x - camera.x);
    const y = Math.floor(e.y - camera.y);
    ctx.fillStyle = '#7b7b86';
    ctx.fillRect(x, y+8, e.w, e.h-8);
    ctx.fillStyle = '#8f8f99';
    ctx.beginPath(); ctx.arc(x+e.w/2, y+10, 14, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#222'; ctx.fillRect(x+e.w/2+4, y+6, 3, 3);
  }

  function drawFinish() {
    const x = Math.floor(finishRect.x - camera.x);
    const y = Math.floor(finishRect.y - camera.y);
    ctx.fillStyle = '#e5eefc'; ctx.fillRect(x+TILE/2-2, y, 4, finishRect.h);
    ctx.fillStyle = '#ff4d6d';
    ctx.beginPath(); ctx.moveTo(x+TILE/2+2, y+10); ctx.lineTo(x+TILE/2+2+30, y+18); ctx.lineTo(x+TILE/2+2, y+26); ctx.closePath(); ctx.fill();
  }

  function draw() {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    const cx = - (camera.x * 0.3) % 300;
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    for (let i=-1;i<5;i++) {
      const bx = cx + i*300, cy = 40;
      ctx.beginPath();
      ctx.ellipse(bx+60, cy+10, 50, 28, 0, 0, Math.PI*2);
      ctx.ellipse(bx+100, cy+5, 40, 24, 0, 0, Math.PI*2);
      ctx.ellipse(bx+20, cy+5, 35, 22, 0, 0, Math.PI*2);
      ctx.fill();
    }
    for (let ty=0; ty<level.length; ty++) for (let tx=0; tx<level[0].length; tx++) {
      const ch = level[ty][tx]; if (ch===' '|| ch==='S' || ch==='o' || ch==='e') continue; drawTile(tx, ty, ch);
    }
    yarns.forEach(drawYarn); enemies.forEach(drawEnemy); drawFinish(); drawCat();
    if (gameOver) banner("Koci odpoczynek… Naciśnij R"); if (win) banner(`Wygrana! Kłębków: ${score}. R aby zagrać ponownie`);
  }

  function banner(text) {
    ctx.save(); ctx.globalAlpha = 0.75; ctx.fillStyle = '#000'; ctx.fillRect(80, canvas.height/2 - 60, canvas.width-160, 120); ctx.restore();
    ctx.textAlign = 'center'; ctx.font = '28px system-ui, sans-serif'; ctx.fillStyle = '#fff'; ctx.fillText(text, canvas.width/2, canvas.height/2 + 8);
  }

  let last = performance.now();
  function frame(now) {
    const dt = Math.min(33, now - last) / 16.67; last = now;
    update(dt); draw(); requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  if (window.matchMedia("(max-width: 820px)").matches) { document.querySelector('.btnbar').style.display = 'flex'; }
})();
</script>
</body>
</html>
